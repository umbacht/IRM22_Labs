{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Oblique;\f2\fswiss\fcharset0 Helvetica-Bold;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww19120\viewh13780\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs72 \cf0 	*********************\
	*****Makefiles*****\
	*********************
\fs26 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \expnd0\expndtw0\kerning0
A simple makefile consists of "rules" with the following shape:\
\

\f1\i target
\f0\i0  ... : 
\f1\i dependencies
\f0\i0  ...\
        
\f1\i command
\f0\i0 \
        ...\
\

\f2\b 4 Basic Rules:
\f0\b0 \
1) The computer starts reading the makefile from the top. As soon as it finds a target, it will execute first it\'92s dependencies (if they are targets), then it\'92s command. \
2) A target can both be a file or an action to be carried out (e.g clean, all) .\
3) If a target is a file, it will only execute the command if any of the dependencies changed.\
4) If the target is an action, it will execute it whenever it\'92s called\
\
everything else builds logically around these simple rules.\
\
\

\f2\b Example:
\f0\b0 \
\
all: sum_numbers\
\
sum_numbers: sum_numbers.o functions.o\
	gcc sum_numbers.o functions.o -o sum_numbers\
\
sum_numbers.o: sum_numbers.c\
	gcc -c sum_numbers.c\
functions.o:  \
	gcc -c functions.c\
\
The following steps happen when you use \'84make\'93 for the first time:\
1. The Computer goes to first target he finds. In this case it\'92s called \'84all\'93. \
2. The Computer checks the dependencies. If the dependencies are not an existing file, they must be a target and the computer will jump to that target. In this case, the computer jumps to the target \'84sum_numbers\'93\
3. Again it checks the dependancies of sum_numbers. sum numbers.o and functions.o are not yet files, thus the computer jumps to their respective target.\
4. When it arrives at sum_numbers.o it checks the dependencies. The dependency sum_numbers.c is a is a file but sum_numbers.o isn\'92t. Thus it executes the command \
gcc -c sum_numbers.c\
anyways. This is according to rule 4). This creates the file sum_numbers.o\
5. The computer does the same thing for functions.o. Here there are no dependencies listed, but the result is the same. He executes:\
gcc -c functions.c\
6. Finally, all the dependencies of sum_numbers are taken care of and the computer executes: \
gcc sum_numbers.o functions.o -o sum_numbers\
\
Now, when try to run make a second time, it becomes interesting: \
\
1.  The Computer goes to first target he finds. In this case it\'92s called \'84all\'93. \
2.  The Computer checks the dependencies. There is one target \'84sum_numbers\'93 and the computer will jump to that target. all is not a file, it is an action and thus it is executed\
3. He checks the dependencies of that target and thus jumps to \'84sum_numbers.o\'93\
4. Sum_numbers.o is now a file, thus it only executes the command when the dependencies change (according to rule 3). Thus it will only execute the line: \
gcc -c sum_numbers.c\
if the file \'84sum_numbers.c\'93 changed\
5. The Computer jumps to the second dependency \'84functions.o\'93. This is again now a file, and thus only executes when the dependency changes. But if there is no dependency, it will not execute again, when it exists. This done to save time for unnecessary recompiling.\
\
\
more in: http://web.mit.edu/gnu/doc/html/make_2.html\
}